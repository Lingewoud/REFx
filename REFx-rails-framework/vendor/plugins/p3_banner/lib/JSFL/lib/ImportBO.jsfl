var ImportBO = {	config : '',	doc	 : '',	init : function( config ) {		this.config = config;		this.doc	= fl.getDocumentDOM();		ExportFile.init( config );	},	importXML : function (success, onlySWF) {				//Load external file		var xml = Utils.loadXML(config.outputFilePath+'input.xml');		if ( !xml ) {			Logger.log("Error loading the XML",Logger.CRITICAL);			return false;		} else {						var docArray = this.parseXml(xml);						if ( docArray != false ) {				Logger.log("Processing xml");			} else {				return false;			}		}				// replace mergeFields & Steps		this.replaceFields(docArray);				//export swf		this.doc.exportSWF(this.config.outputSWFFilePath);				//export jpg		this.createJPG('end');				//hide swfBackground		this.layerRemove('swfBackground');				//Export labeled kerframes for gif animation		var frCount = this.exportKeyframes();				//Create the GIF animation		this.createGIF( frCount );		return true;	},		layerHide : function (layerName) {		var lyr = this.findLayer( layerName );				lyr[0].visible = false;	},		layerRemove : function (layerName) {		var lyr = this.findLayer( layerName );				this.doc.getTimeline().deleteLayer( lyr[1] );	},		findLayer : function ( layerName ) {		var layers = fl.getDocumentDOM().getTimeline().layers;		for( var idx = 0; idx < layers.length; idx++ ) {			if( layers[idx].name.toLowerCase() == layerName.toLowerCase() )			return Array( layers[idx], idx );		}	},		replaceFields : function ( docArray ) {				this.replaceStepFields( docArray['steps'] );		this.replaceMergeFields( docArray['merge'] );			},		replaceStepFields : function ( steps ) {				Logger.log( 'replacing step content:');				for( var idx in steps ) {						var instances = fl.findObjectInDocByName( steps[idx].name, this.doc );						if ( instances.length > 0 ) { 			    			for( var itx in instances ) {					fl.selectElement(instances[itx], false);										if ( this.doc.selection.length > 0 ) {						Logger.log( '	Item \'' + steps[idx].name + '\' will be replaced by library item \'' + steps[idx].id + '\'.' );						this.doc.swapElement( steps[idx].id );						instances[itx].name = steps[idx].name;					}					instances[itx].obj.selected = false;				}			}		}	},		replaceMergeFields : function ( merge ) {				Logger.log( 'replacing merge content:');				for( var idx in merge ) {						this.doc.library.editItem(merge[idx].id);			var tl = this.doc.getTimeline().layers[0].frames[0].elements;								for ( var tf in tl ) {				if ( tl[tf].elementType == 'text' ) {											Logger.log( '	Text string \'' + tl[tf].getTextString() + '\' of item \'' + merge[idx].id + '\' will be replaced with \'' + merge[idx].txt + '\'.' );						tl[tf].setTextString( merge[idx].txt );				}			}						this.doc.exitEditMode();		}	},		exportKeyframes : function() {				var tl 			= this.doc.getTimeline();		var labelArr	= Array();		var count		= 0;				for ( var idx in tl.layers) {			var lyr = tl.layers[idx];						if( lyr.name.toLowerCase() == "exportlabels") {				for ( var fx in lyr.frames) {					if(fx == lyr.frames[fx].startFrame && lyr.frames[fx].name != '') {						ExportFile.exportFrameAsPNG(lyr.frames[fx], 'fr' + count);						count++;					}				}						}		}				return count;	},			parseXml : function (xmlString) {		var docArray = { steps : new Array(), merge : new Array() };				try {			new XML(xmlString);			Logger.log("Number of steps found in XML:" + xmlString.steps.children().length());		} catch (p_error) {			Logger.log("Error parsing the XML. "+p_error);			return false;		}		// add steps to docArray		var steps = xmlString.steps.children();				for( var idx in steps ) {						var stepObj = {				name	: steps[idx].@cid,				type 	: steps[idx].options.children()[0].@type,				id		: steps[idx].options.children()[0].@cid,				txt		: steps[idx].options.children()[0].text,				img		: steps[idx].options.children()[0].img.@src			};						docArray.steps.push(stepObj);			//Logger.log(steps[idx].options.children()[0].toXMLString());			//Logger.log(stepObj.id);		}				// add mergefields		var merge = xmlString.merge.children();				for( var idx in merge ) {						var mergeObj = {				id 		: merge[idx].@cid,				txt		: merge[idx],				img		: merge[idx].img.@src							}						docArray.merge.push( mergeObj );			//Logger.log(mergeObj.id);			//Logger.log(mergeObj.txt);		}				return docArray;	},		createGIF : function ( frCount ) {		var frInterval = ( this.config.gifDuration * 24 ) / frCount;				Logger.log('Creating new file for GIF export');		fl.createDocument();				var newDoc = fl.getDocumentDOM();		newDoc.height = this.doc.height;		newDoc.width = this.doc.width;    	newDoc.framerate = 24;						for( var fr = 0; fr < frCount + 1; fr++ ) {			if( fr > 0 ) {				newDoc.getTimeline().insertBlankKeyframe( fr * frInterval );			}						var file = this.config.outputFilePath + 'fr' + fr + '.png'						if( FLfile.exists( file ) && fr < frCount ) {				try {					Logger.log('	Importing: ' + file );										newDoc.importFile( file );					newDoc.getTimeline().layers[0].frames[ fr * frInterval ].elements[0].x = Math.round(0);					newDoc.getTimeline().layers[0].frames[ fr * frInterval ].elements[0].y = Math.round(0);				} catch(e) {					Logger.log('Error importing file: ' + e, Logger.CRITICAL);				}			}		}				ExportFile.publishAsGIF( config.outputFileName, newDoc );		newDoc.close( false );	},		createJPG : function(frameName) {				var tl 			= this.doc.getTimeline();		var labelArr	= Array();				for ( var idx in tl.layers) {			var lyr = tl.layers[idx];						if( lyr.name.toLowerCase() == "exportlabels") {				for ( var fx in lyr.frames) {					if(fx == lyr.frames[fx].startFrame && lyr.frames[fx].name == frameName) {						ExportFile.exportFrameAsJPG(lyr.frames[fx], config.outputFileName);						break;					}				}						}		}	}}
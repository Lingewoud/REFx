var ExportBO = {	config : '',	doc	 : '',	init : function( config ) {		this.config = config;		this.doc	= fl.getDocumentDOM();		ExportFile.init( config );	},	exportXMLAndImages : function ( success ) {		var libArray = { img : new Object(), txt : new Object(), merge : new Object() };		var xmlString = '<?xml version="1.0" encoding="UTF-8"?><banner  sourcepath="'+ config.documentName +'"><preview><img src="' + this.exportKeyframe('end', 'end') + '.png" /></preview><steps>';		var mergeString = '';		var filesArray = Array();		var i = 0;				for ( var idx in this.doc.library.items ) {			var item = this.getItemTypeAndVar( this.doc.library.items[idx] );			if( typeof(item) == 'object' && ( item instanceof Array )) {				if ( libArray[item[0]][item[1]] == undefined ) {					libArray[item[0]][item[1]] = new Object();					libArray[item[0]][item[1]]['keys'] = 0;				}				libArray[item[0]][item[1]][item.join( '_' )] = this.doc.library.items[idx];				libArray[item[0]][item[1]].keys++;				if ( item[0] != 'merge') filesArray.push( this.doc.library.items[idx] );			}		}				for ( var key in libArray ) {			for ( var idx in libArray[key] ) {				if ( libArray[key][idx].keys > 0 ) {					if( key != 'merge' ) {						xmlString += this.formatStep( key, libArray[key][idx], idx, i );					} else {						mergeString += this.formatMerge( libArray[key][idx], idx, i );					}				}				i++;			}		}				xmlString += '</steps><merge>'+ mergeString +'</merge></banner>';				ExportFile.exportPNGArray( filesArray );		FLfile.write( config.outputFilePath+'output.xml', xmlString );				return true;	},			formatStep : function ( type, node, sid, count ) {		var retVal = '<step'+ count +' cid="'+ sid +'"><preview><img src="'+ this.exportKeyframe(sid) + '.png" /></preview><fieldname></fieldname><fielddesc></fielddesc><type>'+ type +'switch</type><options>';		var txtVal	 = '';		var i	 = 0;				for ( var idx in node ){			if( node[idx].name != undefined ) {				retVal += '<option'+ i +' cid="'+ idx +'" type="'+ type +'">';				retVal += '<preview><img src="'+ this.replaceAndExportOption( { name : sid, id: idx } ) + '.png" /></preview>';								if( type == 'txt' ) {					this.doc.library.editItem(node[idx].name);					var tl = this.doc.getTimeline().layers[0].frames[0].elements;										for ( var tf in tl ) {						if ( tl[tf].elementType == 'text' ) {							retVal += '<img src="' + node[idx].name + '.png" />';							retVal += '<text><![CDATA['+ tl[tf].getTextString() +']]></text>';							break;						}					}					this.doc.exitEditMode();				}  else {					retVal += '<img src="'+ node[idx].name + '.png" />';				}								retVal += '</option'+ i+'>';			}			i++;		}				retVal += '</options></step'+ count +'>';				return retVal;	},		replaceAndExportOption : function ( step ) {				var instances = fl.findObjectInDocByName( step.name, this.doc );		var fileName	= 'preview_' + step.id.toString();				for ( var el in instances ) {			instances[el].obj.selected = true;						if ( this.doc.selection.length > 0 ) {				this.doc.swapElement( step.id );				instances[el].name = step.name;			}						instances[el].obj.selected = false;		}							this.exportKeyframe(step.name, fileName)		return fileName;	},		formatMerge : function ( node, sid, count) {		var retVal = '';			for ( var idx in node ) {			if( node[idx].name != undefined ) {				this.doc.library.editItem(node[idx].name);				var tl = this.doc.getTimeline().layers[0].frames[0].elements;								for ( var tf in tl ) {					if ( tl[tf].elementType == 'text' ) {						retVal += '<mergeText'+ count +' cid="'+ idx +'" ><![CDATA['+ tl[tf].getTextString() +']]></mergeText'+ count + '>';					}				}			}					this.doc.exitEditMode();		}				return retVal;	},		getItemTypeAndVar : function ( item ) {		var itemArray = item.name.split('_');				if(itemArray[0] == 'img' || itemArray[0] == 'txt' || itemArray[0] == 'merge') {			return itemArray;		}	},		exportKeyframe : function( lbl, fileName) {		var tl = this.doc.getTimeline();				for ( var idx in tl.layers) {			var lyr = tl.layers[idx];						if( lyr.name.toLowerCase() == "exportlabels") {				for ( var fx in lyr.frames) {					if(fx == lyr.frames[fx].startFrame) {						if ( lyr.frames[fx].name.toLowerCase() == lbl ) {														ExportFile.exportFrameAsPNG(lyr.frames[fx], fileName);													return lyr.frames[fx].name;						}					}				}						ExportFile.exportFrameAsPNG(lyr.frames[fx]);				return lyr.frames[fx].name;			}		}	}}